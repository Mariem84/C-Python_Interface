\chapter{Conception and Realisation}
\label{chapter:conception}

\section{Literature and basics}
At the beginning, it was necessary to acquire some basics about quantum mechanics (density matrix, Maxwell-Bloch equations..) by reading some introductory literature ~\cite{bastard1992}. A concrete example for the simulation and the numerical solving of the Maxwell-Bloch system was described in the paper of Ziolkowski.\\
QuTiP, a Python Toolbox for simulating the dynamics of open quantum systems, was then the starting point. It offered a variety of examples using Jupyter Notebooks: an interactive tool designed to expose code blocks with human-friendly text which makes data analysis easier to share and reproduce, used in this case to describe quantum mechanic systems, such as Single-Atom Lasing, Quantum Monte Carlo Trajectories...\\
\section{Python/C++ Interface}
Creating the Python/C++ Interface was possible through different means:\\
\begin{itemize}
\item Boost.Python: Boost.Python is an open source C++ library which provides an interface for binding C++ classes and functions to Python. It does enable a safe wrapping of C++ functions and support many of its features. But it is bound to GCC which leads to a huge dependance and it uses extensively C++ template causing possible compilation problems and the use of a large amount of memory. \\
\item ctpyes: ctypes is a foreign library for Python, that allows calling DLLs or shared libraries and wrapping them in pure Python. It is a convenient way to reach for a few functions within a DLL, but not to make large C++ libraries available to Python in performance-critical situations.\\
\item SWIG (Simplified Wrapper and Interface Generator): It is a language neutral compiler that turns ANSI C/C++ declarations into scripting language interfaces. It targets Python, Tcl, Perl, MATLAB, etc.. One of its important features is that it is simple and completely automated (generates a fully working Python extension module). In fact, it creates two different files; a C/C++ source file (module\textunderscore name)\textunderscore wrap.c or (module\textunderscore name)\textunderscore wrap.cxx and a Python source file (module\textunderscore name).py. The generated C/C++ source file contains the low-level wrappers that need to be compiled and linked with the rest of the C/C++ library to create an extension module. The Python source file contains high-level support code. This is the file that will be imported(see Fig.\ref{fig:swig}).\\
\begin{figure}[htb]
  \centering
  \includegraphics[width=0.5\textwidth]{figures/swig_func}
  \caption{Functionality of SWIG}
  \label{fig:swig}
\end{figure}
\end{itemize}
After installing SWIG, a Python module was created starting from an interface file and a header file written in C++. The next step was to wrap a C++ class in order to create instances of this class and modify its attributes in the Python Testprogram. Then the complete C++ library was gradually elaborated, adding each time required attributes and declarations.\\
\section{Serialisation of input parameters}
The next point to handle was the input parameters, how to extract them from an XML File and then store them with results at the end. The first option was to use exml or lxml libraries, which could parse XML files but the resulting objects having NoType made handling them problematic. Therefore, a simple object-XML mapper for Python called dexml was applied to serialize the Metadata by defining subclasses of the class dexml.Model and saving the parameters as instances.\\
\section{Storing results}
Furthermore, it was necessary to specify the file format for the simulation results, which lead to the following options:\\
\begin{itemize}
\item XML: XML's biggest advantage is that it provides developers with a tool that concisely and unambiguously defines the format of data records. However it is not suitable for large amount of data.\\
\item VTK: It is a powerful tool to viisualize scalars, vectors, complex numbers.. but  requires a diffcult setup and an understanding of the framework.\\ 
\item HDF5: HDF5 is a data model, library, and file format for storing and managing data. It supports an unlimited variety of datatypes, and is designed for flexible and efficient I/O and for high volume and complex data. HDF5 is portable and extensible, allowing applications to evolve in their use of HDF5. The HDF5 Technology suite includes tools and applications for managing, manipulating, viewing, and analyzing data in the HDF5 format. \\ 
\end{itemize}
All that considered, HDF5 is the most suitable file format not only to store large amount of data (results) but also different types simultaneously (Metadata).
\section{Git}
After settling the C++ library that contains all the necessary classes and functions, using SWIG to incorporate it in Python, choosing dexml for serialisation of metadata and HDF5 for storage of results, a Git project was created to gather all the pieces, register every step of the realisation and facilitate data exchange and work coordination between me and my supervisor. \\
\section{Makefile/CMake}
To get more experience in handling scientific projects, it was extremely efficient to understand the process of Makefiles and then CMake and apply them on my work. 
\begin{itemize}
\item Makefiles are a simple way to organize code compilation, through rules specified as as a list of target entries, in order to build executable programs from many modules. It only rebuilds in case of new modules added to the program.
\item CMake is a cross platform build system, that automatically generates Makefiles using the CMakeListst.txt file, that specifies the packages, libraries, source files,.. needed to build.
\end{itemize}  
